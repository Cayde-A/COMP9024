
//////////////////////////////////////////////////
// Stack:
//      size   0
//      top    8
//      items  16  --->  long [size]  in heap
//////////////////////////////////////////////////

StackGetSize(stack) {
  return SccRead64(stack, 0);
}

StackSetSize(stack, size) {
  SccWrite64(stack, 0, size);
}

StackGetTop(stack) {
  return SccRead64(stack, 8);
}

StackSetTop(stack, topPos) {
  SccWrite64(stack, 8, topPos);
}

StackGetItems(stack) {
  return SccRead64(stack, 16);
}

StackSetItems(stack, pItems) {
  SccWrite64(stack, 16, pItems);
}

ReleaseStack(stack) {
  long items;
  
  items = StackGetItems(stack);
  SccFree(items);
  SccFree(stack);
}

CreateStack() {
  long pStack;
  long pItems;
  long size;
  long top;
  // A small size for testing
  size = 2;
  top = 0 - 1; 
  // 3 fields
  pStack = SccMalloc(8 * 3);
  pItems = SccMalloc(size * 8);
  // set each field
  StackSetSize(pStack, size);
  StackSetTop(pStack, top);
  StackSetItems(pStack, pItems);  
  return pStack;
}

StackIsEmpty(stack) {
  long top;
  
  top = StackGetTop(stack);
  return SccEqual(top, 0 - 1);
}

StackIsFull(stack) {
  long size;
  long top;
  
  top = StackGetTop(stack);
  size = StackGetSize(stack);
  return SccEqual(top, size - 1);
}


StackPush(stack, item) {
  long top;
  long items;
  long size;
  long newItems;
  
  // Now the stack is not full.
  top = StackGetTop(stack);
  if (StackIsFull(stack)) {
    //output(top);
    size = StackGetSize(stack);
    items = StackGetItems(stack);
    // double its size
    newItems = SccMalloc(size * 2 * 8);
    // copy existing contents
    memcpy(newItems, items, size * 8);
    // Release the old items
    SccFree(items);
    // update its size and newItems
    StackSetSize(stack, size * 2);
    StackSetItems(stack, newItems);
    // 
    items = newItems;
    //putchar(120);
    //putchar(120);
    //putchar(10);
  }

  // push the item
  SccWrite64(items, (top + 1) * 8, item);
  // update the stack pointer
  StackSetTop(stack, top + 1);  
}

StackPop(stack) {
  long top;
  long items;
  long x;
  
  if (StackIsEmpty(stack)) {
    exit(0-1);  
  }

  top = StackGetTop(stack);   
  items = StackGetItems(stack);
  x = SccRead64(items, 8*top);
  StackSetTop(stack, top-1);
  return x;
}

///////////////////////////////////////////
//
//  base:   2, 8, 16
//
//  output:  "0b", "0o",  "0x"
///////////////////////////////////////////
PrintPrefix(base) {
  if (SccNotEqual(base, 10))
  {
    // digit '0'
    putchar(48);
    if (SccEqual(base, 2))
      // 'b'
      putchar(98);
    else if (SccEqual(base, 8))
      // letter 'o'
      putchar(111);
    else if (SccEqual(base, 16))
      // letter 'x'
      putchar(120);      
  }
}

GetAbsoluteValue(x) {
  if (SccLess(x, 0))
    return 0 - x;
  else
    return x;
}

///////////////////////////////////////////
//
//  x:  >= 0
//  base:   2, 8, 10, 16
///////////////////////////////////////////
PrintInteger(x, base) {
  long stack;
  long r;  
  
  // if x < 0, then x = 0 - x
  x = GetAbsoluteValue(x);
  base = GetAbsoluteValue(base);

  stack = CreateStack();

  while (SccNotEqual(x, 0)) {
    r = SccMod(x, base);
    x = x / base;
    StackPush(stack, r);
  }  
  // 0x: hex  0b: bin 0o: oct
  PrintPrefix(base);
  // 
  while (SccLogicNot(StackIsEmpty(stack))) {
    r = StackPop(stack);
    if (SccLessEqual(r, 9)) {
      // 1 --> '1' (0x31, 49)
      // 1 + 48 == 49
      putchar(r + 48);
    } else if (SccLessEqual(r, 15)) {
      // 10 --> 'A' (0x41, 65);  11 --> 'B', ...
      // 10 + 55 == 65
      putchar(r + 55);
    } else {
      // unknown base ---> '?'
      putchar(63);
    }    
  }  
  ReleaseStack(stack);
  
  // '\n'
  putchar(10);
}

////////////////////////////////////////////////////////

main(argc, argv, env) {
  long x;
  x = 20249024;
  output(x);
  // '\n'
  putchar(10);
  
  PrintInteger(x, 16);
  PrintInteger(x, 10);
  PrintInteger(x, 8);
  PrintInteger(x, 2);
  return 0;
}


